kappa.angle <- sqrt(mod$estimate[(N-1)*N+3*N+1:N]^2+mod$estimate[(N-1)*N+4*N+1:N]^2)
kappa.angle
###
###
### ok, this seems to kinda work in principle but seems very unstable
### also, the estimated autocorrelation behaves very differently, depending
### on the starting values
###
###
### next try: fix mean turning angle to 0 to reduce parameters
mllk_ar1<-function(theta.star,x,N){
Gamma <- diag(N)
Gamma[!Gamma] <- exp(theta.star[1:((N-1)*N)])
Gamma <- Gamma/rowSums(Gamma)
delta <- solve(t(diag(N)-Gamma+1),rep(1,N))
autocor <- plogis(theta.star[(N-1)*N+1:N])
mu.step <- exp(theta.star[(N-1)*N+(N+1):(2*N)])
sigma.step <- exp(theta.star[(N-1)*N+2*N+1:N])
# change to before: mu.angle fixed
mu.angle <- rep(0,N)
kappa.angle <- exp(theta.star[(N-1)*N+3*N+1:N])
allprobs <- matrix(1,dim(x)[1],N)
ind.step <- which(!is.na(x$step))[-1] # change: we omit first step
# in order to always have the step in t-1
ind.angle <- which(!is.na(x$angle))
for (j in 1:N){
step.prob <- rep(1,dim(x)[1])
angle.prob <- rep(1,dim(x)[1]) # missing observations stay at value 1
# here comes the autocorrelation!
mu.step_auto <- (1-autocor[j])*mu.step[j] + autocor[j]*x$step[ind.step-1]
step.prob[ind.step] <- dgamma(x$step[ind.step],
shape=mu.step_auto[j]^2/sigma.step[j]^2,
scale=sigma.step[j]^2/mu.step_auto[j]) # rephrase parameters
angle.prob[ind.angle] <- dvm(x$angle[ind.angle],mu.angle[j],kappa.angle[j])
allprobs[,j] <- step.prob * angle.prob
}
foo <- delta%*%diag(allprobs[1,])
l <- log(sum(foo))
phi <- foo/sum(foo)
for (t in 2:length(x)){
foo <- phi%*%Gamma%*%diag(allprobs[t,])
l <- l+log(sum(foo))
phi <- foo/sum(foo)
}
return(-l)
}
# starting values
theta = c(
-2,-2, # values to construct TPM
0.3,0.5, # autocorrelation [0,1]
20,35, # means of step for each state [0,Inf)
5, 10, # sd of step for each state [0,Inf)
#0, 0, # means of angle for each state [-pi,pi]
2, 4 # kappa of angle for each state [0,Inf)
)
# transformation for unconstrained optimization
theta.star = c(
theta[1:2], # values to construct TPM
qlogis(theta[3:4]), # autocorrelation
log(theta[5:6]), # step mean
theta[7:8], # step sd
# for parameter of von Mises distribution: same transformation as in
# function n2w of moveHMM package
#theta[9:10] * cos(theta[11:12]), # angle mean
log(theta[9:10]) # angle kappa
)
mllk_ar1(theta.star=theta.star, x=schwalbe_77, 2) # works
# minimize -logL
mod <- nlm(mllk_ar1,theta.star,x=schwalbe_77[2:4480,],N=2,print.level=2)
mod
## re-transformation to natural parameters
## TPM
N=2
Gamma <- diag(N)
Gamma[!Gamma] <- exp(mod$estimate[1:((N-1)*N)])
Gamma <- Gamma/rowSums(Gamma)
Gamma
delta <- solve(t(diag(N)-Gamma+1),rep(1,N))
delta
# autocorrelation
plogis(mod$estimate[(N-1)*N+1:N])
# step length
mu.step <- exp(mod$estimate[(N-1)*N+(N+1):(2*N)])
mu.step
sigma.step <- exp(mod$estimate[(N-1)*N+2*N+1:N])
sigma.step
# turning angles
kappa.angle <- exp(mod$estimate[(N-1)*N+3*N+1:N])
kappa.angle
### to be continued
mod$m
mod$estimate
# autocorrelation
autocor <- plogis(mod$estimate[(N-1)*N+1:N])
mod$minimum
numeric(8)
states_global <- autocor.viterbi(schwalbe_77,
Gamma, delta, autocor, mu.step, sigma.step,
kappa.angle)
# We need TPM Gamma
autocor.viterbi <-function(x, Gamma, delta, autocor,
mu.step, sigma.step, kappa.angle){
n <- dim(x)[1]
allprobs <- matrix(1,n,2)
ind <- which(!is.na(x$step))[-1] # change: we omit first step
# in order to always have the step in t-1
allprobs[ind,] <- cbind(
dgamma(x$step[ind],
shape=mu.step_auto[1]^2/sigma.step[1]^2,
scale=sigma.step[1]^2/mu.step_auto[1]) *
dvm(x$angle[ind],0,kappa.angle[1]), # mu.angle fixed as 0
dgamma(x$step[ind],
shape=mu.step_auto[2]^2/sigma.step[2]^2,
scale=sigma.step[2]^2/mu.step_auto[2]) *
dvm(x$angle[ind],0,kappa.angle[2]) # mu.angle fixed as 0
)
xi <- matrix(0,n,2)
foo <- delta*allprobs[1,]
xi[1,] <- foo/sum(foo)
for (t in 2:n){
foo <- apply(xi[t-1,]*Gamma, 2, max) * allprobs[t,]
xi[t,] <- foo/sum(foo)
}
iv <- numeric(n)
iv[n] <- which.max(xi[n,])
for (t in (n-1):1){
iv[t] <- which.max(Gamma[,iv[t+1]] * xi[t,])
}
return(iv)
}
states_global <- autocor.viterbi(schwalbe_77,
Gamma, delta, autocor, mu.step, sigma.step,
kappa.angle)
# We need TPM Gamma
autocor.viterbi <-function(x, Gamma, delta, autocor,
mu.step, sigma.step, kappa.angle){
n <- dim(x)[1]
allprobs <- matrix(1,n,2)
ind <- which(!is.na(x$step))[-1] # change: we omit first step
# in order to always have the step in t-1
mu.step.1 <- (1-autocor[1])*mu.step[1] + autocor[1]*x$step[ind-1]
mu.step.1 <- (1-autocor[2])*mu.step[2] + autocor[2]*x$step[ind-1]
allprobs[ind,] <- cbind(
dgamma(x$step[ind],
shape=mu.step_auto[1]^2/sigma.step[1]^2,
scale=sigma.step[1]^2/mu.step_auto[1]) *
dvm(x$angle[ind],0,kappa.angle[1]), # mu.angle fixed as 0
dgamma(x$step[ind],
shape=mu.step_auto[2]^2/sigma.step[2]^2,
scale=sigma.step[2]^2/mu.step_auto[2]) *
dvm(x$angle[ind],0,kappa.angle[2]) # mu.angle fixed as 0
)
xi <- matrix(0,n,2)
foo <- delta*allprobs[1,]
xi[1,] <- foo/sum(foo)
for (t in 2:n){
foo <- apply(xi[t-1,]*Gamma, 2, max) * allprobs[t,]
xi[t,] <- foo/sum(foo)
}
iv <- numeric(n)
iv[n] <- which.max(xi[n,])
for (t in (n-1):1){
iv[t] <- which.max(Gamma[,iv[t+1]] * xi[t,])
}
return(iv)
}
states_global <- autocor.viterbi(schwalbe_77,
Gamma, delta, autocor, mu.step, sigma.step,
kappa.angle)
# We need TPM Gamma
autocor.viterbi <-function(x, Gamma, delta, autocor,
mu.step, sigma.step, kappa.angle){
n <- dim(x)[1]
allprobs <- matrix(1,n,2)
ind <- which(!is.na(x$step))[-1] # change: we omit first step
# in order to always have the step in t-1
mu.step.1 <- (1-autocor[1])*mu.step[1] + autocor[1]*x$step[ind-1]
mu.step.1 <- (1-autocor[2])*mu.step[2] + autocor[2]*x$step[ind-1]
allprobs[ind,] <- cbind(
dgamma(x$step[ind],
shape=mu.step.1^2/sigma.step[1]^2,
scale=sigma.step[1]^2/mu.step.1) *
dvm(x$angle[ind],0,kappa.angle[1]), # mu.angle fixed as 0
dgamma(x$step[ind],
shape=mu.step.2^2/sigma.step[2]^2,
scale=sigma.step[2]^2/mu.step.2) *
dvm(x$angle[ind],0,kappa.angle[2]) # mu.angle fixed as 0
)
xi <- matrix(0,n,2)
foo <- delta*allprobs[1,]
xi[1,] <- foo/sum(foo)
for (t in 2:n){
foo <- apply(xi[t-1,]*Gamma, 2, max) * allprobs[t,]
xi[t,] <- foo/sum(foo)
}
iv <- numeric(n)
iv[n] <- which.max(xi[n,])
for (t in (n-1):1){
iv[t] <- which.max(Gamma[,iv[t+1]] * xi[t,])
}
return(iv)
}
states_global <- autocor.viterbi(schwalbe_77,
Gamma, delta, autocor, mu.step, sigma.step,
kappa.angle)
# We need TPM Gamma
autocor.viterbi <-function(x, Gamma, delta, autocor,
mu.step, sigma.step, kappa.angle){
n <- dim(x)[1]
allprobs <- matrix(1,n,2)
ind <- which(!is.na(x$step))[-1] # change: we omit first step
# in order to always have the step in t-1
mu.step.1 <- (1-autocor[1])*mu.step[1] + autocor[1]*x$step[ind-1]
mu.step.2 <- (1-autocor[2])*mu.step[2] + autocor[2]*x$step[ind-1]
allprobs[ind,] <- cbind(
dgamma(x$step[ind],
shape=mu.step.1^2/sigma.step[1]^2,
scale=sigma.step[1]^2/mu.step.1) *
dvm(x$angle[ind],0,kappa.angle[1]), # mu.angle fixed as 0
dgamma(x$step[ind],
shape=mu.step.2^2/sigma.step[2]^2,
scale=sigma.step[2]^2/mu.step.2) *
dvm(x$angle[ind],0,kappa.angle[2]) # mu.angle fixed as 0
)
xi <- matrix(0,n,2)
foo <- delta*allprobs[1,]
xi[1,] <- foo/sum(foo)
for (t in 2:n){
foo <- apply(xi[t-1,]*Gamma, 2, max) * allprobs[t,]
xi[t,] <- foo/sum(foo)
}
iv <- numeric(n)
iv[n] <- which.max(xi[n,])
for (t in (n-1):1){
iv[t] <- which.max(Gamma[,iv[t+1]] * xi[t,])
}
return(iv)
}
states_global <- autocor.viterbi(schwalbe_77,
Gamma, delta, autocor, mu.step, sigma.step,
kappa.angle)
states_global
# step
plot(schwalbe_77$step, type='l')
# step
plot(schwalbe_77$step, type='l', col=states_global)
# step
plot(schwalbe_77$step, type='l', col=states_global[2])
# step
plot(schwalbe_77$step, type='l', col=states_global[40])
# step
plot(schwalbe_77$step, type='l', col=states_global[112])
points(schwalbe_77$step, pch=19, col=states_global+1)
points(schwalbe_77$step, type='l', col=states_global+1)
points(schwalbe_77$step, type='h', col=states_global+1)
# step
plot(schwalbe_77$step, type='l')
points(schwalbe_77$step, type='h', col=states_global+1)
# step
plot(schwalbe_77$step, type='l')
lines(schwalbe_77$step, type='h', col=states_global+1)
# step
plot(schwalbe_77$step, type='l')
lines(schwalbe_77$step, col=states_global+1)
lines(schwalbe_77$step, pch=2, col=states_global+1)
# step
plot(schwalbe_77$step, type='l')
lines(schwalbe_77$step, pch=2, col=states_global+1)
# step
plot(schwalbe_77$step, type='l')
points(schwalbe_77$step, pch=2, col=states_global+1)
# step
plot(schwalbe_77$step, type='l')
points(schwalbe_77$step, pch=3, col=states_global+1)
# step
plot(schwalbe_77$step, type='l')
points(schwalbe_77$step, pch=4, col=states_global+1)
# step
plot(schwalbe_77$step, type='l')
points(schwalbe_77$step, pch=5, col=states_global+1)
# step
plot(schwalbe_77$step, type='l')
points(schwalbe_77$step, pch=19, col=states_global+1)
# step
plot(schwalbe_77$step, type='h', col=states_global+1)
# step
plot(schwalbe_77$step, type='l')
points(schwalbe_77$step, pch=19, col=states_global+1)
hist(schwalbe_77$step, prob=T)
hist(schwalbe_77$step, prob=T, breaks=20)
hist(schwalbe_77$step, prob=T, breaks=20, xlab="Step size")
mu.step[1]
x <- seq(0,45,by=0.0005)
# We need TPM Gamma
autocor.viterbi <-function(x, Gamma, delta, autocor,
mu.step, sigma.step, kappa.angle){
n <- dim(x)[1]
allprobs <- matrix(1,n,2)
ind <- which(!is.na(x$step))[-1] # change: we omit first step
# in order to always have the step in t-1
allprobs[ind,] <- cbind(
dgamma(x$step[ind],
shape=mu.step[1]^2/sigma.step[1]^2,
scale=sigma.step[1]^2/mu.step[1]) *
dvm(x$angle[ind],0,kappa.angle[1]), # mu.angle fixed as 0
dgamma(x$step[ind],
shape=mu.step[2]^2/sigma.step[2]^2,
scale=sigma.step[2]^2/mu.step[2]) *
dvm(x$angle[ind],0,kappa.angle[2]) # mu.angle fixed as 0
)
xi <- matrix(0,n,2)
foo <- delta*allprobs[1,]
xi[1,] <- foo/sum(foo)
for (t in 2:n){
foo <- apply(xi[t-1,]*Gamma, 2, max) * allprobs[t,]
xi[t,] <- foo/sum(foo)
}
iv <- numeric(n)
iv[n] <- which.max(xi[n,])
for (t in (n-1):1){
iv[t] <- which.max(Gamma[,iv[t+1]] * xi[t,])
}
return(iv)
}
states_global <- autocor.viterbi(schwalbe_77,
Gamma, delta, autocor, mu.step, sigma.step,
kappa.angle)
states_global
x <- seq(0,45,by=0.0005)
curve(dgamma(x, shape=mu.step[1]^2/sigma.step[1]^2,
scale=sigma.step[1]^2/mu.step[1]))
mu.step[1]
sigma.step[1]
x <- seq(0,45,by=0.0005)
curve(dgamma(x, shape=mu.step[1]^2/sigma.step[1]^2,
scale=sigma.step[1]^2/mu.step[1]))
curve(dgamma(x, shape=mu.step[1]^2/sigma.step[1]^2,
scale=sigma.step[1]^2/mu.step[1]), 0,45)
curve(dgamma(x, shape=mu.step[2]^2/sigma.step[2]^2,
scale=sigma.step[2]^2/mu.step[2]), 0,45,add=T)
x <- seq(0,45,by=0.0005)
curve(dgamma(x, shape=mu.step[2]^2/sigma.step[2]^2,
scale=sigma.step[2]^2/mu.step[2]), 0,45,add=T)
x <- seq(0,45,by=0.0005)
curve(dgamma(x, shape=mu.step[2]^2/sigma.step[2]^2,
scale=sigma.step[2]^2/mu.step[2]), 0,45)
mu.step[2]
sigma.step[2]
hist(schwalbe_77$step, prob=T, breaks=20, xlab="Step size")
x <- seq(0,45,by=0.0005)
curve(dgamma(x, shape=mu.step[1]^2/sigma.step[1]^2,
scale=sigma.step[1]^2/mu.step[1]), 0,45, add=T)
curve(dgamma(x, shape=mu.step[2]^2/sigma.step[2]^2,
scale=sigma.step[2]^2/mu.step[2]), 0,45)
hist(schwalbe_77$step, prob=T, breaks=20, xlab="Step size")
x <- seq(0,45,by=0.0005)
curve(dgamma(x, shape=mu.step[1]^2/sigma.step[1]^2,
scale=sigma.step[1]^2/mu.step[1]), 0,45, add=T)
curve(dgamma(x, shape=mu.step[2]^2/sigma.step[2]^2,
scale=sigma.step[2]^2/mu.step[2]), 0,45,add=T)
delta
hist(schwalbe_77$step, prob=T, breaks=20, xlab="Step size")
x <- seq(0,45,by=0.0005)
curve(delta[1]*dgamma(x, shape=mu.step[1]^2/sigma.step[1]^2,
scale=sigma.step[1]^2/mu.step[1]), 0,45, add=T)
curve(delta[2]*dgamma(x, shape=mu.step[2]^2/sigma.step[2]^2,
scale=sigma.step[2]^2/mu.step[2]), 0,45,add=T)
mllk_ar1<-function(theta.star,x,N){
Gamma <- diag(N)
Gamma[!Gamma] <- exp(theta.star[1:((N-1)*N)])
Gamma <- Gamma/rowSums(Gamma)
delta <- solve(t(diag(N)-Gamma+1),rep(1,N))
autocor <- plogis(theta.star[(N-1)*N+1:N])
mu.step <- exp(theta.star[(N-1)*N+(N+1):(2*N)])
sigma.step <- exp(theta.star[(N-1)*N+2*N+1:N])
# change to before: mu.angle fixed
mu.angle <- rep(0,N)
kappa.angle <- exp(theta.star[(N-1)*N+3*N+1:N])
allprobs <- matrix(1,dim(x)[1],N)
ind.step <- which(!is.na(x$step))[-1] # change: we omit first step
# in order to always have the step in t-1
ind.angle <- which(!is.na(x$angle))
for (j in 1:N){
step.prob <- rep(1,dim(x)[1])
angle.prob <- rep(1,dim(x)[1]) # missing observations stay at value 1
# here comes the autocorrelation!
mu.step_auto <- (1-autocor[j])*mu.step[j] + autocor[j]*x$step[ind.step-1]
step.prob[ind.step] <- dgamma(x$step[ind.step],
shape=mu.step_auto[j]^2/sigma.step[j]^2,
scale=sigma.step[j]^2/mu.step_auto[j]) # rephrase parameters
angle.prob[ind.angle] <- dvm(x$angle[ind.angle],mu.angle[j],kappa.angle[j])
allprobs[,j] <- step.prob * angle.prob
}
foo <- delta%*%diag(allprobs[1,])
l <- log(sum(foo))
phi <- foo/sum(foo)
for (t in 2:length(x)){
foo <- phi%*%Gamma%*%diag(allprobs[t,])
l <- l+log(sum(foo))
phi <- foo/sum(foo)
}
return(-l)
}
# starting values
theta = c(
-2,-2, # values to construct TPM
0.3,0.5, # autocorrelation [0,1]
20,35, # means of step for each state [0,Inf)
5, 10, # sd of step for each state [0,Inf)
#0, 0, # means of angle for each state [-pi,pi]
2, 4 # kappa of angle for each state [0,Inf)
)
# transformation for unconstrained optimization
theta.star = c(
theta[1:2], # values to construct TPM
qlogis(theta[3:4]), # autocorrelation
log(theta[5:6]), # step mean
theta[7:8], # step sd
# for parameter of von Mises distribution: same transformation as in
# function n2w of moveHMM package
#theta[9:10] * cos(theta[11:12]), # angle mean
log(theta[9:10]) # angle kappa
)
mllk_ar1(theta.star=theta.star, x=schwalbe_77, 2) # works
# minimize -logL
mod <- nlm(mllk_ar1,theta.star,x=schwalbe_77[2:4480,],N=2,print.level=2)
mod
## re-transformation to natural parameters
## TPM
N=2
Gamma <- diag(N)
Gamma[!Gamma] <- exp(mod$estimate[1:((N-1)*N)])
Gamma <- Gamma/rowSums(Gamma)
Gamma
delta <- solve(t(diag(N)-Gamma+1),rep(1,N))
delta
# autocorrelation
autocor <- plogis(mod$estimate[(N-1)*N+1:N])
autocor
# step length
mu.step <- exp(mod$estimate[(N-1)*N+(N+1):(2*N)])
mu.step
sigma.step <- exp(mod$estimate[(N-1)*N+2*N+1:N])
sigma.step
# turning angles
kappa.angle <- exp(mod$estimate[(N-1)*N+3*N+1:N])
kappa.angle
# We need TPM Gamma
autocor.viterbi <-function(x, Gamma, delta, autocor,
mu.step, sigma.step, kappa.angle){
n <- dim(x)[1]
allprobs <- matrix(1,n,2)
ind <- which(!is.na(x$step))[-1] # change: we omit first step
# in order to always have the step in t-1
allprobs[ind,] <- cbind(
dgamma(x$step[ind],
shape=mu.step[1]^2/sigma.step[1]^2,
scale=sigma.step[1]^2/mu.step[1]) *
dvm(x$angle[ind],0,kappa.angle[1]), # mu.angle fixed as 0
dgamma(x$step[ind],
shape=mu.step[2]^2/sigma.step[2]^2,
scale=sigma.step[2]^2/mu.step[2]) *
dvm(x$angle[ind],0,kappa.angle[2]) # mu.angle fixed as 0
)
xi <- matrix(0,n,2)
foo <- delta*allprobs[1,]
xi[1,] <- foo/sum(foo)
for (t in 2:n){
foo <- apply(xi[t-1,]*Gamma, 2, max) * allprobs[t,]
xi[t,] <- foo/sum(foo)
}
iv <- numeric(n)
iv[n] <- which.max(xi[n,])
for (t in (n-1):1){
iv[t] <- which.max(Gamma[,iv[t+1]] * xi[t,])
}
return(iv)
}
states_global <- autocor.viterbi(schwalbe_77,
Gamma, delta, autocor, mu.step, sigma.step,
kappa.angle)
states_global
# step
plot(schwalbe_77$step, type='l')
points(schwalbe_77$step, pch=19, col=states_global+1) # vernünftige viz fehlt
hist(schwalbe_77$step, prob=T, breaks=20, xlab="Step size")
x <- seq(0,45,by=0.0005)
curve(delta[1]*dgamma(x, shape=mu.step[1]^2/sigma.step[1]^2,
scale=sigma.step[1]^2/mu.step[1]), 0,45, add=T)
curve(delta[2]*dgamma(x, shape=mu.step[2]^2/sigma.step[2]^2,
scale=sigma.step[2]^2/mu.step[2]), 0,45,add=T)
# angle
plot(schwalbe_77$angle, type='l')
points(schwalbe_77$angle, pch=19, col=states_global+1) # vernünftige viz fehlt
hist(schwalbe_77$angle, prob=T, breaks=20, xlab="Step size")
hist(schwalbe_77$angle, prob=T, breaks=30, xlab="Step size")
hist(schwalbe_77$angle, prob=T, breaks=30, xlab="Step size",xlim=c(-1,1))
hist(schwalbe_77$angle, prob=T, breaks=50, xlab="Step size",xlim=c(-1,1))
hist(schwalbe_77$angle, prob=T, breaks=70, xlab="Step size",xlim=c(-1,1))
hist(schwalbe_77$angle, prob=T, breaks=70, xlab="angle",xlim=c(-1,1))
x <- seq(-1,1,by=0.005)
curve(delta[1]*dvm(schwalbe_77$angle, 0,kappa.angle[1] -1,1,add=T))
curve(delta[1]*dvm(schwalbe_77$angle, 0,kappa.angle[1]), -1,1,add=T)
curve(delta[1]*dvm(x, 0,kappa.angle[1]), -1,1,add=T)
curve(delta[2]*dvm(x ,0,kappa.angle[2]), -1,1,add=T)
curve(delta[2]*dvm(x ,0,kappa.angle[2]), -1,1)
curve(delta[1]*dvm(x, 0,kappa.angle[1]), -1,1,add=T)
hist(schwalbe_77$angle, prob=T, breaks=70, xlab="angle",xlim=c(-1,1))
x <- seq(-1,1,by=0.005)
curve(delta[1]*dvm(x, 0,kappa.angle[1]), -1,1,add=T)
curve(delta[2]*dvm(x ,0,kappa.angle[2]), -1,1,add=T)
curve(delta[2]*dvm(x ,0,kappa.angle[2]), -1,1)
