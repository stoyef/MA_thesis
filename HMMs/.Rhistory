}
llks
for (iteration in 4:10){
# starting values
theta = c(
rep(-2,N*(N-1)), # values to construct TPM
runif(N,0,1), # autocorrelation [0,1]
runif(N,-2,2), # means of angle for each state [-pi,pi]
runif(N,5,1000) # kappa of angle for each state [0,Inf)
)
# transformation for unconstrained optimization
theta.star = c(
theta[1:(N*(N-1))], # values to construct TPM
qlogis(theta[N*(N-1)+1:N]), # autocorrelation
# for parameter of von Mises distribution: same transformation as in
# function n2w of moveHMM package
theta[N*(N-1)+N+1:N] * cos(theta[N*(N-1)+2*N+1:N]), # angle mean
theta[N*(N-1)+N+1:N] * sin(theta[N*(N-1)+2*N+1:N]) # angle kappa
)
# minimize -logL
mod <- nlm(mllk_ar1_turningangle,theta.star,x=schwalbe_77[2:4480,],N=2,print.level=0,
iterlim = 1000)
mods <- append(mods, list(mod$estimate))
llks[iteration] <- -mod$minimum
}
llks
for (iteration in 5:10){
# starting values
theta = c(
rep(-2,N*(N-1)), # values to construct TPM
runif(N,0,1), # autocorrelation [0,1]
runif(N,-2,2), # means of angle for each state [-pi,pi]
runif(N,5,1000) # kappa of angle for each state [0,Inf)
)
# transformation for unconstrained optimization
theta.star = c(
theta[1:(N*(N-1))], # values to construct TPM
qlogis(theta[N*(N-1)+1:N]), # autocorrelation
# for parameter of von Mises distribution: same transformation as in
# function n2w of moveHMM package
theta[N*(N-1)+N+1:N] * cos(theta[N*(N-1)+2*N+1:N]), # angle mean
theta[N*(N-1)+N+1:N] * sin(theta[N*(N-1)+2*N+1:N]) # angle kappa
)
# minimize -logL
mod <- nlm(mllk_ar1_turningangle,theta.star,x=schwalbe_77[2:4480,],N=2,print.level=0,
iterlim = 1000)
mods <- append(mods, list(mod$estimate))
llks[iteration] <- -mod$minimum
}
for (iteration in 5:10){
# starting values
theta = c(
rep(-2,N*(N-1)), # values to construct TPM
runif(N,0,1), # autocorrelation [0,1]
runif(N,-2,2), # means of angle for each state [-pi,pi]
runif(N,5,1000) # kappa of angle for each state [0,Inf)
)
# transformation for unconstrained optimization
theta.star = c(
theta[1:(N*(N-1))], # values to construct TPM
qlogis(theta[N*(N-1)+1:N]), # autocorrelation
# for parameter of von Mises distribution: same transformation as in
# function n2w of moveHMM package
theta[N*(N-1)+N+1:N] * cos(theta[N*(N-1)+2*N+1:N]), # angle mean
theta[N*(N-1)+N+1:N] * sin(theta[N*(N-1)+2*N+1:N]) # angle kappa
)
# minimize -logL
mod <- nlm(mllk_ar1_turningangle,theta.star,x=schwalbe_77[2:4480,],N=2,print.level=0,
iterlim = 1000)
mods <- append(mods, list(mod$estimate))
llks[iteration] <- -mod$minimum
}
for (iteration in 5:10){
# starting values
theta = c(
rep(-2,N*(N-1)), # values to construct TPM
runif(N,0,1), # autocorrelation [0,1]
runif(N,-2,2), # means of angle for each state [-pi,pi]
runif(N,5,1000) # kappa of angle for each state [0,Inf)
)
# transformation for unconstrained optimization
theta.star = c(
theta[1:(N*(N-1))], # values to construct TPM
qlogis(theta[N*(N-1)+1:N]), # autocorrelation
# for parameter of von Mises distribution: same transformation as in
# function n2w of moveHMM package
theta[N*(N-1)+N+1:N] * cos(theta[N*(N-1)+2*N+1:N]), # angle mean
theta[N*(N-1)+N+1:N] * sin(theta[N*(N-1)+2*N+1:N]) # angle kappa
)
# minimize -logL
mod <- nlm(mllk_ar1_turningangle,theta.star,x=schwalbe_77[2:4480,],N=2,print.level=0,
iterlim = 1000)
mods <- append(mods, list(mod$estimate))
llks[iteration] <- -mod$minimum
}
llks
for (iteration in 6:10){
# starting values
theta = c(
rep(-2,N*(N-1)), # values to construct TPM
runif(N,0,1), # autocorrelation [0,1]
runif(N,-2,2), # means of angle for each state [-pi,pi]
runif(N,5,1000) # kappa of angle for each state [0,Inf)
)
# transformation for unconstrained optimization
theta.star = c(
theta[1:(N*(N-1))], # values to construct TPM
qlogis(theta[N*(N-1)+1:N]), # autocorrelation
# for parameter of von Mises distribution: same transformation as in
# function n2w of moveHMM package
theta[N*(N-1)+N+1:N] * cos(theta[N*(N-1)+2*N+1:N]), # angle mean
theta[N*(N-1)+N+1:N] * sin(theta[N*(N-1)+2*N+1:N]) # angle kappa
)
# minimize -logL
mod <- nlm(mllk_ar1_turningangle,theta.star,x=schwalbe_77[2:4480,],N=2,print.level=0,
iterlim = 1000)
mods <- append(mods, list(mod$estimate))
llks[iteration] <- -mod$minimum
}
llks
for (iteration in 7:10){
# starting values
theta = c(
rep(-2,N*(N-1)), # values to construct TPM
runif(N,0,1), # autocorrelation [0,1]
runif(N,-2,2), # means of angle for each state [-pi,pi]
runif(N,5,1000) # kappa of angle for each state [0,Inf)
)
# transformation for unconstrained optimization
theta.star = c(
theta[1:(N*(N-1))], # values to construct TPM
qlogis(theta[N*(N-1)+1:N]), # autocorrelation
# for parameter of von Mises distribution: same transformation as in
# function n2w of moveHMM package
theta[N*(N-1)+N+1:N] * cos(theta[N*(N-1)+2*N+1:N]), # angle mean
theta[N*(N-1)+N+1:N] * sin(theta[N*(N-1)+2*N+1:N]) # angle kappa
)
# minimize -logL
mod <- nlm(mllk_ar1_turningangle,theta.star,x=schwalbe_77[2:4480,],N=2,print.level=0,
iterlim = 1000)
mods <- append(mods, list(mod$estimate))
llks[iteration] <- -mod$minimum
}
for (iteration in 7:10){
# starting values
theta = c(
rep(-2,N*(N-1)), # values to construct TPM
runif(N,0,1), # autocorrelation [0,1]
runif(N,-2,2), # means of angle for each state [-pi,pi]
runif(N,5,1000) # kappa of angle for each state [0,Inf)
)
# transformation for unconstrained optimization
theta.star = c(
theta[1:(N*(N-1))], # values to construct TPM
qlogis(theta[N*(N-1)+1:N]), # autocorrelation
# for parameter of von Mises distribution: same transformation as in
# function n2w of moveHMM package
theta[N*(N-1)+N+1:N] * cos(theta[N*(N-1)+2*N+1:N]), # angle mean
theta[N*(N-1)+N+1:N] * sin(theta[N*(N-1)+2*N+1:N]) # angle kappa
)
# minimize -logL
mod <- nlm(mllk_ar1_turningangle,theta.star,x=schwalbe_77[2:4480,],N=2,print.level=0,
iterlim = 1000)
mods <- append(mods, list(mod$estimate))
llks[iteration] <- -mod$minimum
}
for (iteration in 7:10){
# starting values
theta = c(
rep(-2,N*(N-1)), # values to construct TPM
runif(N,0,1), # autocorrelation [0,1]
runif(N,-2,2), # means of angle for each state [-pi,pi]
runif(N,5,1000) # kappa of angle for each state [0,Inf)
)
# transformation for unconstrained optimization
theta.star = c(
theta[1:(N*(N-1))], # values to construct TPM
qlogis(theta[N*(N-1)+1:N]), # autocorrelation
# for parameter of von Mises distribution: same transformation as in
# function n2w of moveHMM package
theta[N*(N-1)+N+1:N] * cos(theta[N*(N-1)+2*N+1:N]), # angle mean
theta[N*(N-1)+N+1:N] * sin(theta[N*(N-1)+2*N+1:N]) # angle kappa
)
# minimize -logL
mod <- nlm(mllk_ar1_turningangle,theta.star,x=schwalbe_77[2:4480,],N=2,print.level=0,
iterlim = 1000)
mods <- append(mods, list(mod$estimate))
llks[iteration] <- -mod$minimum
}
for (iteration in 7:10){
# starting values
theta = c(
rep(-2,N*(N-1)), # values to construct TPM
runif(N,0,1), # autocorrelation [0,1]
runif(N,-2,2), # means of angle for each state [-pi,pi]
runif(N,5,1000) # kappa of angle for each state [0,Inf)
)
# transformation for unconstrained optimization
theta.star = c(
theta[1:(N*(N-1))], # values to construct TPM
qlogis(theta[N*(N-1)+1:N]), # autocorrelation
# for parameter of von Mises distribution: same transformation as in
# function n2w of moveHMM package
theta[N*(N-1)+N+1:N] * cos(theta[N*(N-1)+2*N+1:N]), # angle mean
theta[N*(N-1)+N+1:N] * sin(theta[N*(N-1)+2*N+1:N]) # angle kappa
)
# minimize -logL
mod <- nlm(mllk_ar1_turningangle,theta.star,x=schwalbe_77[2:4480,],N=2,print.level=0,
iterlim = 1000)
mods <- append(mods, list(mod$estimate))
llks[iteration] <- -mod$minimum
}
llks
for (iteration in 7:10){
# starting values
theta = c(
rep(-2,N*(N-1)), # values to construct TPM
runif(N,0,1), # autocorrelation [0,1]
runif(N,-2,2), # means of angle for each state [-pi,pi]
runif(N,5,1000) # kappa of angle for each state [0,Inf)
)
# transformation for unconstrained optimization
theta.star = c(
theta[1:(N*(N-1))], # values to construct TPM
qlogis(theta[N*(N-1)+1:N]), # autocorrelation
# for parameter of von Mises distribution: same transformation as in
# function n2w of moveHMM package
theta[N*(N-1)+N+1:N] * cos(theta[N*(N-1)+2*N+1:N]), # angle mean
theta[N*(N-1)+N+1:N] * sin(theta[N*(N-1)+2*N+1:N]) # angle kappa
)
# minimize -logL
mod <- nlm(mllk_ar1_turningangle,theta.star,x=schwalbe_77[2:4480,],N=2,print.level=0,
iterlim = 1000)
mods <- append(mods, list(mod$estimate))
llks[iteration] <- -mod$minimum
}
for (iteration in 7:10){
# starting values
theta = c(
rep(-2,N*(N-1)), # values to construct TPM
runif(N,0,1), # autocorrelation [0,1]
runif(N,-2,2), # means of angle for each state [-pi,pi]
runif(N,5,1000) # kappa of angle for each state [0,Inf)
)
# transformation for unconstrained optimization
theta.star = c(
theta[1:(N*(N-1))], # values to construct TPM
qlogis(theta[N*(N-1)+1:N]), # autocorrelation
# for parameter of von Mises distribution: same transformation as in
# function n2w of moveHMM package
theta[N*(N-1)+N+1:N] * cos(theta[N*(N-1)+2*N+1:N]), # angle mean
theta[N*(N-1)+N+1:N] * sin(theta[N*(N-1)+2*N+1:N]) # angle kappa
)
# minimize -logL
mod <- nlm(mllk_ar1_turningangle,theta.star,x=schwalbe_77[2:4480,],N=2,print.level=0,
iterlim = 1000)
mods <- append(mods, list(mod$estimate))
llks[iteration] <- -mod$minimum
}
for (iteration in 7:10){
# starting values
theta = c(
rep(-2,N*(N-1)), # values to construct TPM
runif(N,0,1), # autocorrelation [0,1]
runif(N,-2,2), # means of angle for each state [-pi,pi]
runif(N,5,1000) # kappa of angle for each state [0,Inf)
)
# transformation for unconstrained optimization
theta.star = c(
theta[1:(N*(N-1))], # values to construct TPM
qlogis(theta[N*(N-1)+1:N]), # autocorrelation
# for parameter of von Mises distribution: same transformation as in
# function n2w of moveHMM package
theta[N*(N-1)+N+1:N] * cos(theta[N*(N-1)+2*N+1:N]), # angle mean
theta[N*(N-1)+N+1:N] * sin(theta[N*(N-1)+2*N+1:N]) # angle kappa
)
# minimize -logL
mod <- nlm(mllk_ar1_turningangle,theta.star,x=schwalbe_77[2:4480,],N=2,print.level=0,
iterlim = 1000)
mods <- append(mods, list(mod$estimate))
llks[iteration] <- -mod$minimum
}
for (iteration in 7:10){
# starting values
theta = c(
rep(-2,N*(N-1)), # values to construct TPM
runif(N,0,1), # autocorrelation [0,1]
runif(N,-2,2), # means of angle for each state [-pi,pi]
runif(N,5,1000) # kappa of angle for each state [0,Inf)
)
# transformation for unconstrained optimization
theta.star = c(
theta[1:(N*(N-1))], # values to construct TPM
qlogis(theta[N*(N-1)+1:N]), # autocorrelation
# for parameter of von Mises distribution: same transformation as in
# function n2w of moveHMM package
theta[N*(N-1)+N+1:N] * cos(theta[N*(N-1)+2*N+1:N]), # angle mean
theta[N*(N-1)+N+1:N] * sin(theta[N*(N-1)+2*N+1:N]) # angle kappa
)
# minimize -logL
mod <- nlm(mllk_ar1_turningangle,theta.star,x=schwalbe_77[2:4480,],N=2,print.level=0,
iterlim = 1000)
mods <- append(mods, list(mod$estimate))
llks[iteration] <- -mod$minimum
}
for (iteration in 7:10){
# starting values
theta = c(
rep(-2,N*(N-1)), # values to construct TPM
runif(N,0,1), # autocorrelation [0,1]
runif(N,-2,2), # means of angle for each state [-pi,pi]
runif(N,5,1000) # kappa of angle for each state [0,Inf)
)
# transformation for unconstrained optimization
theta.star = c(
theta[1:(N*(N-1))], # values to construct TPM
qlogis(theta[N*(N-1)+1:N]), # autocorrelation
# for parameter of von Mises distribution: same transformation as in
# function n2w of moveHMM package
theta[N*(N-1)+N+1:N] * cos(theta[N*(N-1)+2*N+1:N]), # angle mean
theta[N*(N-1)+N+1:N] * sin(theta[N*(N-1)+2*N+1:N]) # angle kappa
)
# minimize -logL
mod <- nlm(mllk_ar1_turningangle,theta.star,x=schwalbe_77[2:4480,],N=2,print.level=0,
iterlim = 1000)
mods <- append(mods, list(mod$estimate))
llks[iteration] <- -mod$minimum
}
llks
for (iteration in 9:10){
# starting values
theta = c(
rep(-2,N*(N-1)), # values to construct TPM
runif(N,0,1), # autocorrelation [0,1]
runif(N,-2,2), # means of angle for each state [-pi,pi]
runif(N,5,1000) # kappa of angle for each state [0,Inf)
)
# transformation for unconstrained optimization
theta.star = c(
theta[1:(N*(N-1))], # values to construct TPM
qlogis(theta[N*(N-1)+1:N]), # autocorrelation
# for parameter of von Mises distribution: same transformation as in
# function n2w of moveHMM package
theta[N*(N-1)+N+1:N] * cos(theta[N*(N-1)+2*N+1:N]), # angle mean
theta[N*(N-1)+N+1:N] * sin(theta[N*(N-1)+2*N+1:N]) # angle kappa
)
# minimize -logL
mod <- nlm(mllk_ar1_turningangle,theta.star,x=schwalbe_77[2:4480,],N=2,print.level=0,
iterlim = 1000)
mods <- append(mods, list(mod$estimate))
llks[iteration] <- -mod$minimum
}
llks
for (iteration in 9:10){
# starting values
theta = c(
rep(-2,N*(N-1)), # values to construct TPM
runif(N,0,1), # autocorrelation [0,1]
runif(N,-2,2), # means of angle for each state [-pi,pi]
runif(N,5,1000) # kappa of angle for each state [0,Inf)
)
# transformation for unconstrained optimization
theta.star = c(
theta[1:(N*(N-1))], # values to construct TPM
qlogis(theta[N*(N-1)+1:N]), # autocorrelation
# for parameter of von Mises distribution: same transformation as in
# function n2w of moveHMM package
theta[N*(N-1)+N+1:N] * cos(theta[N*(N-1)+2*N+1:N]), # angle mean
theta[N*(N-1)+N+1:N] * sin(theta[N*(N-1)+2*N+1:N]) # angle kappa
)
# minimize -logL
mod <- nlm(mllk_ar1_turningangle,theta.star,x=schwalbe_77[2:4480,],N=2,print.level=0,
iterlim = 1000)
mods <- append(mods, list(mod$estimate))
llks[iteration] <- -mod$minimum
}
for (iteration in 9:10){
# starting values
theta = c(
rep(-2,N*(N-1)), # values to construct TPM
runif(N,0,1), # autocorrelation [0,1]
runif(N,-2,2), # means of angle for each state [-pi,pi]
runif(N,5,1000) # kappa of angle for each state [0,Inf)
)
# transformation for unconstrained optimization
theta.star = c(
theta[1:(N*(N-1))], # values to construct TPM
qlogis(theta[N*(N-1)+1:N]), # autocorrelation
# for parameter of von Mises distribution: same transformation as in
# function n2w of moveHMM package
theta[N*(N-1)+N+1:N] * cos(theta[N*(N-1)+2*N+1:N]), # angle mean
theta[N*(N-1)+N+1:N] * sin(theta[N*(N-1)+2*N+1:N]) # angle kappa
)
# minimize -logL
mod <- nlm(mllk_ar1_turningangle,theta.star,x=schwalbe_77[2:4480,],N=2,print.level=0,
iterlim = 1000)
mods <- append(mods, list(mod$estimate))
llks[iteration] <- -mod$minimum
}
llks
for (iteration in 10:10){
# starting values
theta = c(
rep(-2,N*(N-1)), # values to construct TPM
runif(N,0,1), # autocorrelation [0,1]
runif(N,-2,2), # means of angle for each state [-pi,pi]
runif(N,5,1000) # kappa of angle for each state [0,Inf)
)
# transformation for unconstrained optimization
theta.star = c(
theta[1:(N*(N-1))], # values to construct TPM
qlogis(theta[N*(N-1)+1:N]), # autocorrelation
# for parameter of von Mises distribution: same transformation as in
# function n2w of moveHMM package
theta[N*(N-1)+N+1:N] * cos(theta[N*(N-1)+2*N+1:N]), # angle mean
theta[N*(N-1)+N+1:N] * sin(theta[N*(N-1)+2*N+1:N]) # angle kappa
)
# minimize -logL
mod <- nlm(mllk_ar1_turningangle,theta.star,x=schwalbe_77[2:4480,],N=2,print.level=0,
iterlim = 1000)
mods <- append(mods, list(mod$estimate))
llks[iteration] <- -mod$minimum
}
llks
mods
sum(round(llks,3)==round(max(llks),3))/length(llks) # proportion of optimal runs
max(llks)
mod$estimate <- mods[[2]]
## re-transformation to natural parameters
## TPM
N=3
Gamma <- diag(N)
Gamma[!Gamma] <- exp(mod$estimate[1:((N-1)*N)])
Gamma <- Gamma/rowSums(Gamma)
Gamma
mod$estimate
mod$estimate <- mods[[1]]
mods[[1]]
mods[[3]]
mods[[4]]
mod$estimate <- mods[[4]]
Gamma <- diag(N)
Gamma[!Gamma] <- exp(mod$estimate[1:((N-1)*N)])
Gamma <- Gamma/rowSums(Gamma)
Gamma
delta <- solve(t(diag(N)-Gamma+1),rep(1,N))
delta
mods[[5]]
mods[[6]]
mods[[7]]
exp(-2)
Gamma <- diag(N)
Gamma[!Gamma] <- exp(mod$estimate[1:((N-1)*N)])
Gamma <- Gamma/rowSums(Gamma)
Gamma
Gamma[2,3]
Gamma[2,3]<-0
delta <- solve(t(diag(N)-Gamma+1),rep(1,N))
delta
# autocorrelation
autocor <- plogis(mod$estimate[(N-1)*N+1:N])
autocor
# angle
mu.angle <- Arg(mod$estimate[(N-1)*N+(N+1):(2*N)]+1i*mod$estimate[(N-1)*N+2*N+1:N])
kappa.angle <- sqrt(mod$estimate[(N-1)*N+(N+1):(2*N)]^2+mod$estimate[(N-1)*N+2*N+1:N]^2)
mu.angle
kappa.angle
# We need TPM Gamma
autocor.viterbi <-function(x, Gamma, delta, autocor,
mu.angle, kappa.angle){
n <- dim(x)[1]
allprobs <- matrix(1,n,3)
ind <- which(!is.na(x$angle))[-c(1:1)] # change: we omit first step
# in order to always have the step in t-1
allprobs[ind,] <- cbind(
dvm(x$angle[ind],mu.angle[1],kappa.angle[1]),
dvm(x$angle[ind],mu.angle[2],kappa.angle[2]),
dvm(x$angle[ind],mu.angle[3],kappa.angle[3])
)
xi <- matrix(0,n,3)
foo <- delta*allprobs[1,]
xi[1,] <- foo/sum(foo)
for (t in 2:n){
foo <- apply(xi[t-1,]*Gamma, 2, max) * allprobs[t,]
xi[t,] <- foo/sum(foo)
}
iv <- numeric(n)
iv[n] <- which.max(xi[n,])
for (t in (n-1):1){
iv[t] <- which.max(Gamma[,iv[t+1]] * xi[t,])
}
return(iv)
}
states_global <- autocor.viterbi(schwalbe_77,
Gamma, delta, autocor, mu.angle, kappa.angle)
states_global
# step
plot(schwalbe_77$angle, type='l')
points(schwalbe_77$angle, pch=19, col=states_global+1) # vernünftige viz fehlt
hist(schwalbe_77$angle, prob=T, breaks=80, xlab="Step size",
ylim = c(0,12),xlim=c(-pi,pi))
x <- seq(-pi,pi,by=0.0005)
curve(delta[1]*dvm(x,mu.angle[1],kappa.angle[1]), -pi,pi, add=T,
col=4,lwd=2)
curve(delta[2]*dvm(x,mu.angle[2],kappa.angle[2]), -pi,pi, add=T,
col=6,lwd=2)
curve(delta[3]*dvm(x,mu.angle[3],kappa.angle[3]), -pi,pi, add=T,
col=7,lwd=2)
curve(delta[1]*dvm(x,mu.angle[1],kappa.angle[1])+
delta[2]*dvm(x,mu.angle[2],kappa.angle[2])+
delta[3]*dvm(x,mu.angle[3],kappa.angle[3]), -pi,pi, add=T,
col=2,lwd=2)
