# 2022-06-03 
# Functions that plot different HMMs


#' Plot states decoded by Viterbi algorithm
#' 
#' This function plots the states decoded by the Viterbi algorithm.
#' 
#' @param states Vector of states (natural numbers, range 1-N).
#' @param names optional, specifies the names of the states. If "none", state 1-N will be used.
#' @param title bool, indicator if the plot should have a title.
#' 
#' @export
#' @rdname plot_states
plot_states <- function(states, names="none", title=TRUE){
  N <- length(unique(states))
  require(RColorBrewer)
  pal <- brewer.pal(N,'Dark2')
  
  if (title){
    plot(states, pch=19, bty='n', main='Decoded states using Viterbi',
         xlab='Index', ylab='State', col=pal[states])
  } else{
    plot(states, pch=19, bty='n', main='',
         xlab='Index', ylab='State', col=pal[states])
  }
  if (names[1]=="none"){
    legend(length(states)/1.5, 1.8, paste("State",1:N), col=pal,lwd=1.5,bty='n')
  } else{
    legend(length(states)/1.5, 1.8, names, col=pal,lwd=1.5,bty='n')
  }
}


#' Density plot of estimated distributions
#'
#' Plots the estimted distributions along with a histogram of the values.
#' 
#' @param data Input data for histogram.
#' @param dist string, indicates the kind of distribution, one of ['gamma', 'von Mises'].
#' @param param Vector of distribution parameters, in customary form, e.g. for 2 state gamma
#'              HMM: c(\eqn{\mu1,\mu2,\sigma1,\sigma2}).
#' @param N int, number of states (or weighted distributions) to be plotted.
#' @param delta Input vector for parameter delta.
#' @param title optional, title of the plot, if "none", then no title.
#' @param breaks optional, specify number of breaks of the histogram.
#' 
#' @export
#' @rdname plot_fitted_dist
plot_fitted_dist <- function(data, dist, param, N, delta, title="none", breaks=30){
  require(CircStats)
  require(RColorBrewer)
  pal <- brewer.pal(N+1, 'Dark2')
  dens <- matrix(NA, nrow=10000,ncol=N)
  x <- seq(min(data, na.rm=TRUE),max(data, na.rm=TRUE),length=10000)
  
  if (dist=='gamma'){
    mu <- param[1:N]
    sigma <- param[N+1:N]
    for (i in 1:N){
      dens[,i] = delta[i]*dgamma(x, shape=param$mu[i]^2/param$sigma[i]^2, scale=param$sigma[i]^2/param$mu[i])
    }
  } else if (dist=='vm'){
    mu <- param[1:N]
    kappa <- param[N+1:N]
    for (i in 1:N){
      dens[,i] = delta[i]*dvm(x, param$mu[i], param$kappa[i])
    }
  }
  total_dist <- apply(dens,1,sum)
  
  if (title=="none"){
    hist(data, breaks=breaks, probability = TRUE,
         main="", xlab="x")#, ylim=c(0,max(total_dist, na.rm=TRUE)))
  }else{
    hist(data, breaks=breaks, probability = TRUE,
         main=title, xlab="x")#, ylim=c(0,max(total_dist, na.rm=TRUE)))
  }
  for (i in 1:N){
    lines(x,dens[,i],col=pal[i], lwd=2)
  }
  lines(x,total_dist,col=pal[N+1],lwd=2)
  legend('topright', c(paste("State",1:N),"Total"), bty='n', lwd=2,
         col=pal)
}


#' Plot decoded data 
#'
#' Plot a data vector, colored with regard to the Viterbi decoded states.
#' 
#' @param data Data vector to be plotted.
#' @param states Vector of ecoded states.
#' @param col Color of the states.
#' @param name optional, y-axis label, if "none" than "data".
#' @param title optional, title of the plot, if "none", then no title.
#' @param legend optional, bool, specifies if there should be a legend.
#' 
#' @export
#' @rdname plot_decoded_data
plot_decoded_data <- function(data, states, col, name="none", title="none", legend=TRUE){
  if (name=="none"){
    plot(NULL,xlim=c(0,length(data)),ylim=c(min(data,na.rm=TRUE),max(data,na.rm=TRUE)),
         ylab='data',xlab='time',bty='n')
  } else{
    plot(NULL,xlim=c(0,length(data)),ylim=c(min(data,na.rm=TRUE),max(data,na.rm=TRUE)),
         ylab=name,xlab='time',bty='n')
  }
  segments(x0 = 1:(length(data) - 1), y0 = data[-length(data)],
           x1 = 2:length(data), y1 = data[-1],
           col = col[states[-length(data)]], lwd = 1.5)
  if (title=="none"){
    title(main="")
  } else{
    title(main=title)
  }
  if (legend){
    legend('topright',
           c('state 1', 'state 2'),
           col=col,lwd=1.5,
           bty='n')
  }  
}


#' Boxplot of different simulation runs
#'
#' Generate a boxplot of several fitted values, generated by fitting a model
#' to data. Includes a comparison to the true value.
#' 
#' @param data Simulated values of the parameter.
#' @param name Name of the parameter.
#' @param true_value optional, true parameter value, 0 if no horizontal hould 
#' be drawn.
#'                        
#' @export
#' @rdname boxplot_params
#' 
boxplot_params <- function(data, name,true_value,...){
  args=list(x=data,xlab=name,...)
  do.call(boxplot,args)
  if (true_value){
    abline(h=true_value,lwd=2,col=2)
  }
}


#' Plot data 
#'
#' Plot a data vector
#' 
#' @param data Data vector to be plotted
#' @param name optional, y-axis label, if "none" than "data"
#' @param title optional, title of the plot, if "none", then no title
#' 
#' @export
#' @rdname plot_data
plot_data <- function(data, name="none", title="none"){
  if (name=="none"){
    plot(data, typ='l',xlab="Index", ylab="Data",bty='n')
  } else{
    plot(data, typ='l',xlab="Index", ylab=name,bty='n')
  }
  if (title=="none"){
    title(main="")
  } else{
    title(main=title)
  }
  
}


#' Full simulation boxplots of estimated parameters
#'
#' Generate a boxplot of all fitted parameters, generated by fitting a model
#' to data. Includes a comparison to the true value. Currently only works
#' for a simulation containing one gamma distributed and one von Mises distributed
#' variable.
#' 
#' @param gamma_mu Fitted values of the parameter mu of the gamma distribution.
#' @param gamma_sigma Fitted values of the parameter sigma of the gamma distribution.
#' @param vm_mu Fitted values of the parameter mu of the von Mises distribution.
#' @param vm_kappa Fitted values of the parameter kappa of the von Mises distribution.
#' @param gamma_auto Fitted values of the autocorrelation parameters of the gamma distribution. 
#'                   0 if no autocorrelation was fitted.
#' @param vm_auto Fitted values of the autocorrelation parameters of the von Mises distribution.
#'                   0 if no autocorrelation was fitted.
#' @param true_values True parameter values, order: [gamma_mu, gamma_sigma, vm_mu, vm_kappa, gamma_auto, vm_auto]
#' @param nstates Number of states fitted (default: 2). Works only for 2 states!
#' be drawn.
#' @param vm_head_pos optional, determines position of heading of von Mises distribution. 
#'                    Only gets used for fitted models without autocorrelation.
#'                        
#' @export
#' @rdname boxplot_sim_params
#' 
boxplot_sim_params <- function(gamma_mu, gamma_sigma, vm_mu, vm_kappa, gamma_auto=0,
                               vm_auto=0, true_values, nstates=2, vm_head_pos=0){
  
  if (length(true_values)==(4*nstates)){
    layout(matrix(c(1,2,3,4),ncol=2,byrow=TRUE))
  } else{
    layout(matrix(c(1,2,3,3),ncol=2,byrow=TRUE))
  }
  
  # boxplot gamma_mu
  boxplot(x=gamma_mu, xlab=expression(mu), cex.lab=2,xaxt='n',cex.axis=1.5)
  axis(1, at=1:nstates, labels=rep("",nstates))
  mtext(c(expression(mu[1]),expression(mu[2])),side=1,at=1:nstates,line=1.25,cex=1.5)
  abline(h=true_values[1:nstates],col=2,lwd=2)
  
  # boxplot gamma_sigma
  boxplot(x=gamma_sigma, xlab=expression(sigma), cex.lab=2,xaxt='n',cex.axis=1.5)
  axis(1, at=1:nstates, labels=rep("",nstates))
  mtext(c(expression(sigma[1]),expression(sigma[2])),side=1,at=1:nstates,line=1.25,cex=1.5)
  abline(h=true_values[nstates+1:nstates],col=2,lwd=2)
  
  # boxplot gamma_auto
  if (length(true_values)>(4*nstates)){
    boxplot(gamma_auto,xlab=expression(phi),cex.lab=2,cex.axis=1.5,ylim=c(0,1),xaxt='n')
    axis(1, at=1:((length(true_values)-4*nstates)/2), labels=rep("",(length(true_values)-4*nstates)/2))
    if ((length(true_values)-4*nstates)/(nstates*2) == 1){ # AR(1)
      mtext(c(expression(phi["1"]),expression(phi["2"])),
            side=1,at=1:nstates,line=1.25,cex=1.5)
      abline(h=true_values[4*nstates+1:nstates],col=2,lwd=2)
    } else if ((length(true_values)-4*nstates)/(nstates*2) == 2){ # AR(2)
      mtext(c(expression(phi["1,1"]),expression(phi["1,2"]),expression(phi["2,1"]),expression(phi["2,2"])),
            side=1,at=1:(2*nstates),line=1.25,cex=1.5)
      abline(h=true_values[4*nstates+1:(2*nstates)],col=2,lwd=2)
    } else if ((length(true_values)-4*nstates)/(nstates*2) == 3){ # AR(3)
      mtext(c(expression(phi["1,1"]),expression(phi["1,2"]),expression(phi["1,3"]),expression(phi["2,1"]),expression(phi["2,2"]),expression(phi["2,3"])),
            side=1,at=1:(3*nstates),line=1.25,cex=1.5)
      abline(h=true_values[4*nstates+1:(3*nstates)],col=2,lwd=2)
    } else{
      return("ERROR: Wrong length of true_values.")
    }
  }
  title("Estimated parameters of gamma distribution",outer=TRUE,line=-2,cex.main=2)
  
  # boxplot vm_mu
  boxplot(x=vm_mu, xlab=expression(mu), cex.lab=2,xaxt='n',cex.axis=1.5)
  axis(1, at=1:nstates, labels=rep("",nstates))
  mtext(c(expression(mu[1]),expression(mu[2])),side=1,at=1:nstates,line=1.25,cex=1.5)
  abline(h=true_values[2*nstates+1:nstates],col=2,lwd=2)
  
  # boxplot vm_kappa
  boxplot(x=vm_kappa, xlab=expression(kappa), cex.lab=2,xaxt='n',cex.axis=1.5)
  axis(1, at=1:nstates, labels=rep("",nstates))
  mtext(c(expression(kappa[1]),expression(kappa[2])),side=1,at=1:nstates,line=1.25,cex=1.5)
  abline(h=true_values[3*nstates+1:nstates],col=2,lwd=2)
  
  # boxplot vm_auto
  if (length(true_values)>(4*nstates)){
    boxplot(vm_auto,xlab=expression(phi),cex.lab=2,cex.axis=1.5,ylim=c(0,1),xaxt='n')
    axis(1, at=1:((length(true_values)-4*nstates)/2), labels=rep("",(length(true_values)-4*nstates)/2))
    if ((length(true_values)-4*nstates)/(nstates*2) == 1){ # AR(1)
      mtext(c(expression(phi["1"]),expression(phi["2"])),
            side=1,at=1:nstates,line=1.25,cex=1.5)
      abline(h=true_values[4*nstates+nstates+1:nstates],col=2,lwd=2)
    } else if ((length(true_values)-4*nstates)/(nstates*2) == 2){ # AR(2)
      mtext(c(expression(phi["1,1"]),expression(phi["1,2"]),expression(phi["2,1"]),expression(phi["2,2"])),
            side=1,at=1:(2*nstates),line=1.25,cex=1.5)
      abline(h=true_values[4*nstates+2*nstates+1:(2*nstates)],col=2,lwd=2)
    } else if ((length(true_values)-4*nstates)/(nstates*2) == 3){ # AR(3)
      mtext(c(expression(phi["1,1"]),expression(phi["1,2"]),expression(phi["1,3"]),expression(phi["2,1"]),expression(phi["2,2"]),expression(phi["2,3"])),
            side=1,at=1:(3*nstates),line=1.25,cex=1.5)
      abline(h=true_values[4*nstates+3*nstates+1:(3*nstates)],col=2,lwd=2)
    } else{
      return("ERROR: Wrong length of true_values.")
    }
  title("Estimated parameters of von Mises distribution",outer=TRUE,line=-2,cex.main=2)
  } else{
    title("Estimated parameters of von Mises distribution",outer=TRUE,line=vm_head_pos,cex.main=2)
  }
  
}








