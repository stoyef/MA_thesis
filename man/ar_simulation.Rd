% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/HMM_sim_functions.R
\name{ar_simulation}
\alias{ar_simulation}
\title{Simulate HMMs with and without autocorrelation}
\usage{
ar_simulation(
  model_sim,
  model_fit,
  N_sim,
  N_fit,
  n_samples,
  Gamma_sim,
  delta_sim,
  param_sim,
  autocor_sim = 0,
  estimate_states = TRUE,
  plot_it = TRUE
)
}
\arguments{
\item{model_sim}{Form of simulated data in a vector: First entry is vector containing 
abbreviated names (in R-jargon) of the distributions 
the data should be sampled from. Second entry is 
vector of degree of autocorrelation for each distribution, 
0=no autocorrelation.}

\item{model_fit}{Form of fitted data in a vector: First entry is vector containing 
abbreviated names (in R-jargon) of the distributions 
to be considered in the Likelihood computation. Second entry is 
vector of degree of autocorrelation for each distribution, 
0=no autocorrelation.}

\item{N_sim}{Number of states of the HMM used for data generation.}

\item{N_fit}{Number of states of the HMM used for fitting the data.}

\item{n_samples}{Number of samples to be generated.}

\item{Gamma_sim}{Full transition probability matrix of simulated data.}

\item{delta_sim}{Initial distribution of simulated data.}

\item{param_sim}{Parameter vector for parameters of the simulated data. In a vector form,
and in the order that is customary: e.g. for a gamma HMM c(\eqn{\mu1,\mu2,\sigma1,\sigma2}).
The order of distributions has to be the same as in model_sim.}

\item{autocor_sim}{Vector of autocorrelation coefficients of simulated data (if there are any,
one value for each time lag and state). The order of distributions has
to be the same as in model_sim.}

\item{estimate_states}{Bool, determines if states are estimated and returned
using Viterbi.}

\item{plot_it}{Bool, determines if resulting densities are plotted.}
}
\value{
List of Fitted model and its parameters (and optional the decoded states).
}
\description{
Top to bottom wrapper function: Simulate from a specified HMM, fit a specified
HMM to the resulting data and return the output. Optionally: Also return the 
decoded states using the Viterbi algorithm. Optionally: Also plot the resulting 
density functions of the weighted distributions.
}
