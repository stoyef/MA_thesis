# 2022-06-03 
# Functions that plot different HMMs


#' Plot states decoded by Viterbi algorithm
#' 
#' This function plots the states decoded by the Viterbi algorithm.
#' 
#' @param states Vector of states (natural numbers, range 1-N).
#' @param names optional, specifies the names of the states. If "none", state 1-N will be used.
#' @param title bool, indicator if the plot should have a title.
#' 
#' @export
#' @rdname plot_states
plot_states <- function(states, names="none", title=TRUE){
  N <- length(unique(states))
  require(RColorBrewer)
  pal <- brewer.pal(N,'Dark2')
  
  if (title){
    plot(states, pch=19, bty='n', main='Decoded states using Viterbi',
         xlab='Index', ylab='State', col=pal[states])
  } else{
    plot(states, pch=19, bty='n', main='',
         xlab='Index', ylab='State', col=pal[states])
  }
  if (names[1]=="none"){
    legend(length(states)/1.5, 1.8, paste("State",1:N), col=pal,lwd=1.5,bty='n')
  } else{
    legend(length(states)/1.5, 1.8, names, col=pal,lwd=1.5,bty='n')
  }
}


#' Density plot of estimated distributions
#'
#' Plots the estimted distributions along with a histogram of the values.
#' 
#' @param data Input data for histogram
#' @param dist string, indicates the kind of distribution, one of ['gamma', 'von Mises'].
#' @param param Vector of distribution parameters, in customary form, e.g. for 2 state gamma
#'              HMM: c(\eqn{\mu1,\mu2,\sigma1,\sigma2}).
#' @param N int, number of states (or weighted distributions) to be plotted.
#' @param delta Input vector for parameter delta
#' @param title optional, title of the plot, if "none", then no title
#' 
#' @export
#' @rdname plot_fitted_dist
plot_fitted_dist <- function(data, dist, param, N, delta, title="none"){
  require(CircStats)
  require(RColorBrewer)
  pal <- brewer.pal(N+1, 'Dark2')
  dens <- matrix(NA, nrow=10000,ncol=N)
  x <- seq(min(data),max(data),length=10000)
  
  if (dist=='gamma'){
    mu <- param[1:N]
    sigma <- param[N+1:N]
    for (i in 1:N){
      dens[,i] = delta[i]*dgamma(x, shape=param$mu[i]^2/param$sigma[i]^2, scale=param$sigma[i]^2/param$mu[i])
    }
  } else if (dist=='vm'){
    mu <- param[1:N]
    kappa <- param[N+1:N]
    for (i in 1:N){
      dens[,i] = delta[i]*dvm(x, param$mu[i], param$kappa[i])
    }
  }
  total_dist <- apply(dens,1,sum)
  
  if (title=="none"){
    hist(data, breaks=30, probability = TRUE,
         main="", xlab="x", ylim=c(0,1.1*max(total_dist)))
  }else{
    hist(data, breaks=30, probability = TRUE,
         main=title, xlab="x", ylim=c(0,1.1*max(total_dist)))
  }
  for (i in 1:N){
    lines(x,dens[,i],col=pal[i], lwd=2)
  }
  lines(x,total_dist,col=pal[N+1],lwd=2)
  legend('topright', c(paste("State",1:N),"Total"), bty='n', lwd=2,
         col=pal)
}


#' Plot data 
#'
#' Plot a data vector
#' 
#' @param data Data vector to be plotted
#' @param name optional, y-axis label, if "none" than "data"
#' @param title optional, title of the plot, if "none", then no title
#' 
#' @export
#' @rdname plot_data
plot_data <- function(data, name="none", title="none"){
  if (name=="none"){
    plot(data, typ='l',xlab="Index", ylab="Data",bty='n')
  } else{
    plot(data, typ='l',xlab="Index", ylab=name,bty='n')
  }
  if (title=="none"){
    title(main="")
  } else{
    title(main=title)
  }
  
}


#' Boxplot of different simulation runs
#'
#' Generate a boxplot of several fitted values, generated by fitting a model
#' to data. Includes a comparison to the true value.
#' 
#' @param data Simulated values of the parameter.
#' @param name Name of the parameter.
#' @param true_value optional, true parameter value, 0 if no horizontal hould 
#' be drawn.
#'                        
#' @export
#' @rdname boxplot_params
#' 
boxplot_params <- function(data, name,true_value,...){
  args=list(x=data,xlab=name,...)
  do.call(boxplot,args)
  if (true_value){
    abline(h=true_value,lwd=2,col=2)
  }
}

